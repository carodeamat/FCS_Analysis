---
title: "Annotation and Visualization"
author: "Carolina"
date: "2025-01-27"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r}

library(tidyverse)
library(Rtsne)
library(umap)
#library(ggcyto)
library(pheatmap)
library(viridis)
library(scales)
library(reshape2)

source("Plot_functions_flow.R")

seed <- 1234
set.seed(seed)

```



```{r}

# Set directories
datapath <- "../results/Pheno_clustering_1234_2025-01-26.rds"
outdir <- "../results"
plotdir <- "../results/plots"

# Read data and transformed expression data
data <- readRDS(datapath)

```

## Including Plots

You can also embed plots, for example:

```{r}

# Set gradient colors
myColor <- inferno(100)

# Obtain clusters information
clusterID <- as.factor(data$metadata$Clusters_pheno)

#Obtain the expression median for each cluster
dataheat <- data.frame(matrix(0, ncol=ncol(data$expr.mat), nrow=length(levels(clusterID))))
for(i in seq_len(ncol(data$expr.mat))){
  dataheat[,i] <- tapply(data$expr.mat[,i], clusterID, median)
}

colnames(dataheat) <- colnames(data$expr.mat)
dataheat <- data.frame(t(dataheat))
colnames(dataheat) <- levels(clusterID)

# Plot heatmap
heat.expr <- pheatmap(dataheat, 
                      color = myColor, 
                      scale = "row", 
                      border_color = NA, 
                      fontsize = 15, 
                      treeheight_row = 0)  


```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.

```{r}

# 2D expression plots
UMAPexpr <- lapply(colnames(data$expr.mat), function(x){
                  plot.expr(data$metadata, 
                            data$expr.mat,
                            x = "UMAP_1",
                            y = "UMAP_2", 
                            color.by=x, 
                            main = x, 
                            size = 2,
                            limits=c(quantile(data$expr.mat[,x], 0.01), 
                                     quantile(data$expr.mat[,x], 0.99))
                  )
                            
})

names(UMAPexpr) <- colnames(data$expr.mat)

for(plot in UMAPexpr) {print(plot)}
```

```{r}

# Change cluster labels

new.labels <- c(
  "1"= "CD4+",
  "2"= "CD57+",
  "3"= "CXCR6+ 2B4lo",
  "4"= "CD56- FceR1g-",
  "5"= "CD62L+ CD4+",
  "6"= "CXCR6+ 2B4+",
  "7"= "CD8+",
  "8"= "CD94+",
  "9"= "CD62L+ CD4-"
)

new.order <- c(
  "5",
  "1",
  "9",
  "4",
  "3",
  "6",
  "7",
  "8",
  "2"
)

data$metadata$Annotation <- new.labels[as.character(data$metadata$Clusters_pheno)]
data$metadata$Annotation <- factor(data$metadata$Annotation, levels = new.labels[new.order])

```


```{r}


UMAPannotated <- plot.feature(data$metadata, 
                              x = "UMAP_1",
                              y = "UMAP_2",
                              color.by = "Annotation", 
                              split.by = NULL,
                              size = 1,
                              alpha = 1,
                              show.cluser.id = TRUE,
                              show.cluser.id.size = 2,
                              colors = "default", # or a vector of colors with length = nClusters
                              main = "UMAP Populations")

print(UMAPannotated)

```

```{r}

# Metadata to evaluate for cluster distribution
groups <- c("Subject", "Sex") # Any categorical metadata information

# Total number of cells per cluster
t.pop <- table(data$metadata$Annotation) 

# Number of cells per cluster distributed in groups
table.list <- lapply(groups, function(x){table(data$metadata[,x], data$metadata$Annotation)})
names(table.list) <- groups

print(t.pop)
print(table.list)


#Barplot of the frequencies of each population in each group
bar.plots <- lapply(groups, function(x){
  bar.plot(table.list[[x]], fill.label = x)
  }
)

names(bar.plots) <- groups

for(plot in bar.plots) {print(plot)}


```

```{r}

# Select the groups to plot
subset.by <- "Clusters_pheno" #or any other variable in metadata
groups <- c("1", "2") # groups to be compared in overlaid density plots

# Subset metadata and expression matrix based on selected categories
sub.data <- lapply(data, function(x){
    subset(x, data$metadata[,subset.by] %in% groups)
    }
  )

# Overlaid density plot
density.plots <- lapply(colnames(sub.data$expr.mat), function(x){
                    dens.plot(sub.data$metadata,
                              sub.data$expr.mat,
                              x = x,
                              color.by = "Annotation",
                              fill.label = "Population",
                              linew = 0.5,
                              alpha=0.6,
                              colors = "default",
                              xlabel = x)
                }
)

names(density.plots) <- colnames(sub.data$expr.mat)

for(plot in density.plots) {print(plot)}

```

